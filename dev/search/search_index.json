{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Capsula","text":"<p>Capsula, a Latin word meaning box, is a Python package designed to help researchers and developers easily capture their command/function execution context for reproducibility.</p> <p>With Capsula, you can capture:</p> <ul> <li>CPU information with <code>CpuContext</code></li> <li>Python version with <code>PlatformContext</code></li> <li>Current working directory with <code>CwdContext</code></li> <li>Git repository information (commit hash, branch, etc.) with <code>GitRepositoryContext</code></li> <li>Output of shell commands (e.g., <code>poetry check --lock</code>) with <code>CommandContext</code></li> <li>Files (e.g., output files, <code>pyproject.toml</code>, <code>requirements.txt</code>) with <code>FileContext</code></li> <li>Arguments of Python functions with <code>FunctionContext</code></li> <li>Environment variables with <code>EnvVarContext</code></li> <li>Uncaught exceptions with <code>UncaughtExceptionWatcher</code></li> <li>Execution time with <code>TimeWatcher</code></li> </ul> <p>The captured contexts are dumped into JSON files for future reference and reproduction.</p>"},{"location":"#usage-example","title":"Usage example","text":"<p>For project-wide settings, prepare a <code>capsula.toml</code> file in the root directory of your project. An example of the <code>capsula.toml</code> file is as follows:</p> <pre><code>[pre-run]\ncontexts = [\n    { type = \"CwdContext\" },\n    { type = \"CpuContext\" },\n    { type = \"GitRepositoryContext\", name = \"capsula\", path = \".\", path_relative_to_project_root = true },\n    { type = \"CommandContext\", command = \"poetry check --lock\", cwd = \".\", cwd_relative_to_project_root = true },\n    { type = \"FileContext\", path = \"pyproject.toml\", copy = true, path_relative_to_project_root = true },\n    { type = \"FileContext\", path = \"poetry.lock\", copy = true, path_relative_to_project_root = true },\n    { type = \"CommandContext\", command = \"pip freeze --exclude-editable &gt; requirements.txt\", cwd = \".\", cwd_relative_to_project_root = true },\n    { type = \"FileContext\", path = \"requirements.txt\", move = true, path_relative_to_project_root = true },\n]\nreporters = [{ type = \"JsonDumpReporter\" }]\n\n[in-run]\nwatchers = [{ type = \"UncaughtExceptionWatcher\" }, { type = \"TimeWatcher\" }]\nreporters = [{ type = \"JsonDumpReporter\" }]\n\n[post-run]\nreporters = [{ type = \"JsonDumpReporter\" }]\n</code></pre> <p>Then, all you need to do is decorate your Python function with the <code>@capsula.run()</code> decorator. You can also use the <code>@capsula.context()</code> decorator to add a context specific to the function.</p> <p>The following is an example of a Python script that estimates the value of \u03c0 using the Monte Carlo method:</p> <pre><code>import random\nimport capsula\n\n@capsula.run()\n@capsula.context(capsula.FileContext.builder(\"pi.txt\", move=True), mode=\"post\")\ndef calculate_pi(n_samples: int = 1_000, seed: int = 42) -&gt; None:\n    random.seed(seed)\n    xs = (random.random() for _ in range(n_samples))\n    ys = (random.random() for _ in range(n_samples))\n    inside = sum(x * x + y * y &lt;= 1.0 for x, y in zip(xs, ys))\n\n    # You can record values to the capsule using the `record` method.\n    capsula.record(\"inside\", inside)\n\n    pi_estimate = (4.0 * inside) / n_samples\n    print(f\"Pi estimate: {pi_estimate}\")\n    capsula.record(\"pi_estimate\", pi_estimate)\n    print(f\"Run name: {capsula.current_run_name()}\")\n\n    with open(\"pi.txt\", \"w\") as output_file:\n        output_file.write(f\"Pi estimate: {pi_estimate}.\")\n\nif __name__ == \"__main__\":\n    calculate_pi(n_samples=1_000)\n</code></pre> <p>After running the script, a directory (<code>calculate_pi_20240630_015823_S3vb</code> in this example) will be created under the <code>vault</code> directory, and you will find the following files there:</p> Example of output <code>pre-run-report.json</code>: <pre><code>{\n  \"cwd\": \"/home/nomura/ghq/github.com/shunichironomura/capsula\",\n  \"cpu\": {\n    \"python_version\": \"3.8.17.final.0 (64 bit)\",\n    \"cpuinfo_version\": [\n      9,\n      0,\n      0\n    ],\n    \"cpuinfo_version_string\": \"9.0.0\",\n    \"arch\": \"X86_64\",\n    \"bits\": 64,\n    \"count\": 12,\n    \"arch_string_raw\": \"x86_64\",\n    \"vendor_id_raw\": \"GenuineIntel\",\n    \"brand_raw\": \"Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz\",\n    \"hz_advertised_friendly\": \"2.9000 GHz\",\n    \"hz_actual_friendly\": \"2.9040 GHz\",\n    \"hz_advertised\": [\n      2900000000,\n      0\n    ],\n    \"hz_actual\": [\n      2904008000,\n      0\n    ],\n    \"stepping\": 5,\n    \"model\": 165,\n    \"family\": 6,\n    \"flags\": [\n      \"3dnowprefetch\",\n      \"abm\",\n      \"adx\",\n      \"aes\",\n      \"apic\",\n      \"arch_capabilities\",\n      \"arch_perfmon\",\n      \"avx\",\n      \"avx2\",\n      \"bmi1\",\n      \"bmi2\",\n      \"clflush\",\n      \"clflushopt\",\n      \"cmov\",\n      \"constant_tsc\",\n      \"cpuid\",\n      \"cx16\",\n      \"cx8\",\n      \"de\",\n      \"ept\",\n      \"ept_ad\",\n      \"erms\",\n      \"f16c\",\n      \"flush_l1d\",\n      \"fma\",\n      \"fpu\",\n      \"fsgsbase\",\n      \"fxsr\",\n      \"ht\",\n      \"hypervisor\",\n      \"ibpb\",\n      \"ibrs\",\n      \"ibrs_enhanced\",\n      \"invpcid\",\n      \"invpcid_single\",\n      \"lahf_lm\",\n      \"lm\",\n      \"mca\",\n      \"mce\",\n      \"md_clear\",\n      \"mmx\",\n      \"movbe\",\n      \"msr\",\n      \"mtrr\",\n      \"nopl\",\n      \"nx\",\n      \"osxsave\",\n      \"pae\",\n      \"pat\",\n      \"pcid\",\n      \"pclmulqdq\",\n      \"pdcm\",\n      \"pdpe1gb\",\n      \"pge\",\n      \"pni\",\n      \"popcnt\",\n      \"pse\",\n      \"pse36\",\n      \"rdrand\",\n      \"rdrnd\",\n      \"rdseed\",\n      \"rdtscp\",\n      \"rep_good\",\n      \"sep\",\n      \"smap\",\n      \"smep\",\n      \"ss\",\n      \"ssbd\",\n      \"sse\",\n      \"sse2\",\n      \"sse4_1\",\n      \"sse4_2\",\n      \"ssse3\",\n      \"stibp\",\n      \"syscall\",\n      \"tpr_shadow\",\n      \"tsc\",\n      \"vme\",\n      \"vmx\",\n      \"vnmi\",\n      \"vpid\",\n      \"x2apic\",\n      \"xgetbv1\",\n      \"xsave\",\n      \"xsavec\",\n      \"xsaveopt\",\n      \"xsaves\",\n      \"xtopology\"\n    ],\n    \"l3_cache_size\": 12582912,\n    \"l2_cache_size\": \"1.5 MiB\",\n    \"l1_data_cache_size\": 196608,\n    \"l1_instruction_cache_size\": 196608,\n    \"l2_cache_line_size\": 256,\n    \"l2_cache_associativity\": 6\n  },\n  \"git\": {\n    \"capsula\": {\n      \"working_dir\": \"/home/nomura/ghq/github.com/shunichironomura/capsula\",\n      \"sha\": \"db7b86d3ed95e178521cd140505f1c8b25f4f30e\",\n      \"remotes\": {\n        \"origin\": \"ssh://git@github.com/shunichironomura/capsula.git\"\n      },\n      \"branch\": \"update-readme\",\n      \"is_dirty\": false\n    }\n  },\n  \"command\": {\n    \"poetry check --lock\": {\n      \"command\": \"poetry check --lock\",\n      \"cwd\": null,\n      \"returncode\": 0,\n      \"stdout\": \"All set!\\n\",\n      \"stderr\": \"\"\n    },\n    \"pip freeze --exclude-editable &gt; requirements.txt\": {\n      \"command\": \"pip freeze --exclude-editable &gt; requirements.txt\",\n      \"cwd\": null,\n      \"returncode\": 0,\n      \"stdout\": \"\",\n      \"stderr\": \"\"\n    }\n  },\n  \"file\": {\n    \"pyproject.toml\": {\n      \"copied_to\": [\n        \"vault/calculate_pi_20240630_015823_S3vb/pyproject.toml\"\n      ],\n      \"moved_to\": null,\n      \"hash\": {\n        \"algorithm\": \"sha256\",\n        \"digest\": \"9b2ccc978e950a3a4d2b5f3d29eadab593e1ffe8cd48e7606389e214cb82c8a6\"\n      }\n    },\n    \"poetry.lock\": {\n      \"copied_to\": [\n        \"vault/calculate_pi_20240630_015823_S3vb/poetry.lock\"\n      ],\n      \"moved_to\": null,\n      \"hash\": {\n        \"algorithm\": \"sha256\",\n        \"digest\": \"8d89f9943c8e515340a5c8c16b17a30a749d935ffe765024acaaa81fc1ed5587\"\n      }\n    },\n    \"requirements.txt\": {\n      \"copied_to\": [],\n      \"moved_to\": \"vault/calculate_pi_20240630_015823_S3vb\",\n      \"hash\": {\n        \"algorithm\": \"sha256\",\n        \"digest\": \"b7a36d48fda3efc9374d7d8b0fd4d910234497e2cf229001a1c2c76fce35810c\"\n      }\n    }\n  }\n}</code></pre> Example of output <code>in-run-report.json</code>: <pre><code>{\n  \"function\": {\n    \"calculate_pi\": {\n      \"file_path\": \"examples/simple_decorator.py\",\n      \"first_line_no\": 6,\n      \"args\": [],\n      \"kwargs\": {\n        \"n_samples\": 1000\n      }\n    }\n  },\n  \"inside\": 782,\n  \"pi_estimate\": 3.128,\n  \"time\": {\n    \"execution_time\": \"0:00:00.000568\"\n  },\n  \"exception\": {\n    \"exception\": {\n      \"exc_type\": null,\n      \"exc_value\": null,\n      \"traceback\": null\n    }\n  }\n}</code></pre> Example of output <code>post-run-report.json</code>: <pre><code>{\n  \"file\": {\n    \"pi.txt\": {\n      \"copied_to\": [],\n      \"moved_to\": \"vault/calculate_pi_20240630_015823_S3vb\",\n      \"hash\": {\n        \"algorithm\": \"sha256\",\n        \"digest\": \"a64c761cb6b6f9ef1bc1f6afa6ba44d796c5c51d14df0bdc9d3ab9ced7982a74\"\n      }\n    }\n  }\n}</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>You can install Capsula via pip:</p> <pre><code>pip install capsula\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#context","title":"Context","text":"<p>A context encapsulates a piece of information at a specific point in time. It can be anything from the current working directory (<code>CwdContext</code>) to the output of a command (<code>CommandContext</code>). Contexts are used to capture the state of the environment in which a command/function is executed.</p> <p>See the Contexts section for the list of all the built-in contexts.</p>"},{"location":"concepts/#watcher","title":"Watcher","text":"<p>A watcher encapsulates a piece of information by monitoring the execution of a command/function. It can be used to detect uncaught exceptions (<code>UncaughtExceptionWatcher</code>) or measure the execution time (<code>TimeWatcher</code>). Watchers are used to monitor the execution of a command/function.</p> <p>See the Watchers section for more information.</p>"},{"location":"concepts/#encapsulator-and-capsule","title":"Encapsulator and Capsule","text":"<p>You register multiple contexts and/or watchers to an encapsulator. Then, the encapsulator encapsulates the information encapsulated by the contexts and/or watchers into a \"capsule\".</p>"},{"location":"concepts/#reporter","title":"Reporter","text":"<p>A reporter reports the capsule in a specific format. For example, the <code>JsonDumpReporter</code> reports the capsule in JSON format.</p> <p>See the Reporters section for more information.</p>"},{"location":"concepts/#run","title":"Run","text":"<p>A run is a single execution of a command/function. It has three encapsulators: pre-run, in-run, and post-run.</p> Encapsulator When to encapsulate Allowed registrations Pre-run encapsulator Before the execution of the command/function. Contexts In-run encapsulator During the execution of the command/function. Watchers Post-run encapsulator After the execution of the command/function. Contexts <p>For each run, a run directory is created in the <code>vault</code> directory. This directory is used to store the files generated by contexts, watchers, and reporters.</p>"},{"location":"config/","title":"Configuration","text":""},{"location":"config/#capsulatoml-file","title":"<code>capsula.toml</code> file","text":"<p>For project-wide settings, prepare a <code>capsula.toml</code> file in the root directory of your project. An example of the <code>capsula.toml</code> file is as follows:</p> <pre><code>[pre-run]\ncontexts = [\n    { type = \"CwdContext\" },\n    { type = \"CpuContext\" },\n    { type = \"GitRepositoryContext\", name = \"capsula\", path = \".\", path_relative_to_project_root = true },\n    { type = \"CommandContext\", command = \"poetry check --lock\", cwd = \".\", cwd_relative_to_project_root = true },\n    { type = \"FileContext\", path = \"pyproject.toml\", copy = true, path_relative_to_project_root = true },\n    { type = \"FileContext\", path = \"poetry.lock\", copy = true, path_relative_to_project_root = true },\n    { type = \"CommandContext\", command = \"pip freeze --exclude-editable &gt; requirements.txt\", cwd = \".\", cwd_relative_to_project_root = true },\n    { type = \"FileContext\", path = \"requirements.txt\", move = true, path_relative_to_project_root = true },\n]\nreporters = [{ type = \"JsonDumpReporter\" }]\n\n[in-run]\nwatchers = [{ type = \"UncaughtExceptionWatcher\" }, { type = \"TimeWatcher\" }]\nreporters = [{ type = \"JsonDumpReporter\" }]\n\n[post-run]\nreporters = [{ type = \"JsonDumpReporter\" }]\n</code></pre> <p>This configuration file specifies the contexts, watchers, and reporters to be used in the pre-run, in-run, and post-run encapsulators. The <code>JsonDumpReporter</code> is used to dump the captured contexts into JSON files.</p> <p>For each context, watcher, or reporter, the <code>type</code> field specifies the class name of the context, watcher, or reporter. The other fields are used as the keyword arguments to the <code>builder</code> method of the class to create an instance of the class. If the class does not implement the <code>builder</code> method, the <code>__init__</code> method is used instead.</p>"},{"location":"config/#decorators","title":"Decorators","text":"<p>For encapsulating the pre-run, in-run, and post-run capsules for a specific function, you can use the <code>@capsula.run()</code> decorator. You can also use the <code>@capsula.context()</code>, <code>@capsula.watcher()</code>, and <code>@capsula.reporter()</code> decorators to add a context, watcher, or reporter respectively to the function.</p> <p>The following is an example of a Python script that estimates the value of \u03c0 using the Monte Carlo method:</p> <pre><code>import random\nimport capsula\n\n@capsula.run()\n# Register a `FileContext` to the post-run encapsulator.\n@capsula.context(capsula.FileContext.default(\"pi.txt\", move=True), mode=\"post\")\ndef calculate_pi(n_samples: int = 1_000, seed: int = 42) -&gt; None:\n    random.seed(seed)\n    xs = (random.random() for _ in range(n_samples))\n    ys = (random.random() for _ in range(n_samples))\n    inside = sum(x * x + y * y &lt;= 1.0 for x, y in zip(xs, ys))\n    pi_estimate = (4.0 * inside) / n_samples\n\n    # You can record values to the capsule using the `record` method.\n    capsula.record(\"pi_estimate\", pi_estimate)\n    # You can access the current run name using the `current_run_name` function.\n    print(f\"Run name: {capsula.current_run_name()}\")\n\n    with open(\"pi.txt\", \"w\") as output_file:\n        output_file.write(f\"Pi estimate: {pi_estimate}.\")\n\nif __name__ == \"__main__\":\n    calculate_pi(n_samples=1_000)\n</code></pre>"},{"location":"config/#order-of-encapsulation","title":"Order of encapsulation","text":"<p>For each encapsulators, the order of encapsulation is as follows:</p> <ol> <li>Contexts, watchers, and reporters specified in the <code>capsula.toml</code> file, in the order of appearance (from top to bottom).</li> <li>Contexts, watchers, and reporters specified using the <code>@capsula.context()</code> and <code>@capsula.watcher()</code> decorators, in the order of appearance (from top to bottom).</li> </ol>"},{"location":"contexts/","title":"Built-in contexts","text":"<p>Capsula provides several built-in contexts that you can capture. The following is a list of built-in contexts:</p> <ul> <li><code>CommandContext</code> - Captures the output of shell commands.</li> <li><code>CpuContext</code> - Captures the CPU information.</li> <li><code>CwdContext</code> - Captures the current working directory.</li> <li><code>EnvVarContext</code> - Captures the environment variables.</li> </ul> <ul> <li><code>GitRepositoryContext</code> - Captures the Git repository information.</li> <li><code>PlatformContext</code> - Captures the Python version.</li> </ul>"},{"location":"contexts/command/","title":"<code>CommandContext</code>","text":""},{"location":"contexts/command/#capsula.CommandContext","title":"capsula.CommandContext","text":"<pre><code>CommandContext(\n    command: str,\n    *,\n    cwd: Path | None = None,\n    check: bool = True,\n    abort_on_error: bool = True\n)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture the output of a command run in a subprocess.</p> PARAMETER DESCRIPTION <code>command</code> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>check</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>abort_on_error</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_context/_command.py</code> <pre><code>def __init__(\n    self,\n    command: str,\n    *,\n    cwd: Path | None = None,\n    check: bool = True,\n    abort_on_error: bool = True,\n) -&gt; None:\n    self._command = command\n    self._cwd = cwd\n    self._check = check\n    self._abort_on_error = abort_on_error\n</code></pre>"},{"location":"contexts/command/#capsula.CommandContext.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    command: str,\n    *,\n    cwd: Path | str | None = None,\n    check: bool = True,\n    abort_on_error: bool = True,\n    cwd_relative_to_project_root: bool = False\n) -&gt; Callable[[CapsuleParams], CommandContext]\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>Command to run</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Working directory for the command, passed to the <code>cwd</code> argument of <code>subprocess.run</code></p> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>check</code> <p>Whether to raise an exception if the command returns a non-zero exit code, passed to the <code>check</code> argument of `subprocess.run</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>abort_on_error</code> <p>Whether to abort the encapsulation if the command returns a non-zero exit code</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>cwd_relative_to_project_root</code> <p>Whether <code>cwd</code> argument is relative to the project root. Will be ignored if <code>cwd</code> is None or absolute. If True, it will be interpreted as relative to the project root. If False, <code>cwd</code> will be interpreted as relative to the current working directory. It is recommended to set this to True in the configuration file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_context/_command.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    command: Annotated[str, Doc(\"Command to run\")],\n    *,\n    cwd: Annotated[\n        Path | str | None,\n        Doc(\"Working directory for the command, passed to the `cwd` argument of `subprocess.run`\"),\n    ] = None,\n    check: Annotated[\n        bool,\n        Doc(\n            \"Whether to raise an exception if the command returns a non-zero exit code, passed to the `check` \"\n            \"argument of `subprocess.run\",\n        ),\n    ] = True,\n    abort_on_error: Annotated[\n        bool,\n        Doc(\"Whether to abort the encapsulation if the command returns a non-zero exit code\"),\n    ] = True,\n    cwd_relative_to_project_root: Annotated[\n        bool,\n        Doc(\n            \"Whether `cwd` argument is relative to the project root. Will be ignored if `cwd` is None or absolute. \"\n            \"If True, it will be interpreted as relative to the project root. \"\n            \"If False, `cwd` will be interpreted as relative to the current working directory. \"\n            \"It is recommended to set this to True in the configuration file.\",\n        ),\n    ] = False,\n) -&gt; Callable[[CapsuleParams], CommandContext]:\n    def callback(params: CapsuleParams) -&gt; CommandContext:\n        if cwd_relative_to_project_root and cwd is not None and not Path(cwd).is_absolute():\n            cwd_path: Path | None = params.project_root / cwd\n        elif cwd_relative_to_project_root and cwd is None:\n            cwd_path = params.project_root\n        else:\n            cwd_path = Path(cwd) if cwd is not None else None\n\n        return cls(\n            command,\n            cwd=cwd_path,\n            check=check,\n            abort_on_error=abort_on_error,\n        )\n\n    return callback\n</code></pre>"},{"location":"contexts/command/#capsula.CommandContext.abort_on_error","title":"abort_on_error  <code>property</code>","text":"<pre><code>abort_on_error: bool\n</code></pre>"},{"location":"contexts/command/#capsula.CommandContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _CommandContextData\n</code></pre> Source code in <code>capsula/_context/_command.py</code> <pre><code>def encapsulate(self) -&gt; _CommandContextData:\n    logger.debug(f\"Running command: {self._command}\")\n    output = subprocess.run(  # noqa: S602\n        self._command,\n        shell=True,\n        text=True,\n        capture_output=True,\n        cwd=self._cwd,\n        check=self._check,\n    )\n    logger.debug(f\"Ran command: {self._command}. Result: {output}\")\n    return {\n        \"command\": self._command,\n        \"cwd\": self._cwd,\n        \"returncode\": output.returncode,\n        \"stdout\": output.stdout,\n        \"stderr\": output.stderr,\n    }\n</code></pre>"},{"location":"contexts/command/#capsula.CommandContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_command.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"command\", self._command)\n</code></pre>"},{"location":"contexts/cpu/","title":"<code>CpuContext</code>","text":""},{"location":"contexts/cpu/#capsula.CpuContext","title":"capsula.CpuContext","text":"<p>               Bases: <code>ContextBase</code></p> <p>Context to capture CPU information.</p>"},{"location":"contexts/cpu/#capsula.CpuContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; dict[str, Any]\n</code></pre> Source code in <code>capsula/_context/_cpu.py</code> <pre><code>def encapsulate(self) -&gt; dict[str, Any]:\n    return get_cpu_info()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"contexts/cpu/#capsula.CpuContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; str\n</code></pre> Source code in <code>capsula/_context/_cpu.py</code> <pre><code>def default_key(self) -&gt; str:\n    return \"cpu\"\n</code></pre>"},{"location":"contexts/cwd/","title":"<code>CwdContext</code>","text":""},{"location":"contexts/cwd/#capsula.CwdContext","title":"capsula.CwdContext","text":"<p>               Bases: <code>ContextBase</code></p> <p>Context to capture the current working directory.</p>"},{"location":"contexts/cwd/#capsula.CwdContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; Path\n</code></pre> Source code in <code>capsula/_context/_cwd.py</code> <pre><code>def encapsulate(self) -&gt; Path:\n    return Path.cwd()\n</code></pre>"},{"location":"contexts/cwd/#capsula.CwdContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; str\n</code></pre> Source code in <code>capsula/_context/_cwd.py</code> <pre><code>def default_key(self) -&gt; str:\n    return \"cwd\"\n</code></pre>"},{"location":"contexts/envvar/","title":"<code>EnvVarContext</code>","text":""},{"location":"contexts/envvar/#capsula.EnvVarContext","title":"capsula.EnvVarContext","text":"<pre><code>EnvVarContext(name: str)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture an environment variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the environment variable</p> <p> TYPE: <code>str</code> </p> Source code in <code>capsula/_context/_envvar.py</code> <pre><code>def __init__(self, name: Annotated[str, Doc(\"Name of the environment variable\")]) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"contexts/envvar/#capsula.EnvVarContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"contexts/envvar/#capsula.EnvVarContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; str | None\n</code></pre> Source code in <code>capsula/_context/_envvar.py</code> <pre><code>def encapsulate(self) -&gt; str | None:\n    return os.getenv(self.name)\n</code></pre>"},{"location":"contexts/envvar/#capsula.EnvVarContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_envvar.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"env\", self.name)\n</code></pre>"},{"location":"contexts/file/","title":"<code>FileContext</code>","text":""},{"location":"contexts/file/#capsula.FileContext","title":"capsula.FileContext","text":"<pre><code>FileContext(\n    path: Path | str,\n    *,\n    compute_hash: bool = True,\n    hash_algorithm: str | None = None,\n    copy_to: (\n        Iterable[Path | str] | Path | str | None\n    ) = None,\n    move_to: Path | str | None = None,\n    ignore_missing: bool = False\n)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture a file.</p> PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>Path | str</code> </p> <code>compute_hash</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hash_algorithm</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>copy_to</code> <p> TYPE: <code>Iterable[Path | str] | Path | str | None</code> DEFAULT: <code>None</code> </p> <code>move_to</code> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>ignore_missing</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_context/_file.py</code> <pre><code>def __init__(\n    self,\n    path: Path | str,\n    *,\n    compute_hash: bool = True,\n    hash_algorithm: str | None = None,\n    copy_to: Iterable[Path | str] | Path | str | None = None,\n    move_to: Path | str | None = None,\n    ignore_missing: bool = False,\n) -&gt; None:\n    self._path = Path(path)\n    self._hash_algorithm = self._default_hash_algorithm if hash_algorithm is None else hash_algorithm\n    self._compute_hash = compute_hash\n    self._move_to = None if move_to is None else Path(move_to)\n    self._ignore_missing = ignore_missing\n\n    if copy_to is None:\n        self._copy_to: tuple[Path, ...] = ()\n    elif isinstance(copy_to, (str, Path)):\n        self._copy_to = (Path(copy_to),)\n    else:\n        self._copy_to = tuple(Path(p) for p in copy_to)\n</code></pre>"},{"location":"contexts/file/#capsula.FileContext.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    path: Path | str,\n    *,\n    compute_hash: bool = True,\n    hash_algorithm: str | None = None,\n    copy: bool = False,\n    move: bool = False,\n    ignore_missing: bool = False,\n    path_relative_to_project_root: bool = False\n) -&gt; Callable[[CapsuleParams], FileContext]\n</code></pre> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file</p> <p> TYPE: <code>Path | str</code> </p> <code>compute_hash</code> <p>Whether to compute the hash of the file</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hash_algorithm</code> <p>Hash algorithm to use. This will be fed to <code>hashlib.file_digest</code> as the <code>digest</code> argument.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the file to the run directory</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>move</code> <p>Whether to move the file to the run directory</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ignore_missing</code> <p>Whether to ignore if the file does not exist</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>path_relative_to_project_root</code> <p>Whether <code>path</code> is relative to the project root. Will be ignored if <code>path</code> is absolute.If True, it will be interpreted as relative to the project root. If False, <code>path</code> will be interpreted as relative to the current working directory. It is recommended to set this to True in the configuration file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_context/_file.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    path: Annotated[Path | str, Doc(\"Path to the file\")],\n    *,\n    compute_hash: Annotated[bool, Doc(\"Whether to compute the hash of the file\")] = True,\n    hash_algorithm: Annotated[\n        str | None,\n        Doc(\"Hash algorithm to use. This will be fed to `hashlib.file_digest` as the `digest` argument.\"),\n    ] = None,\n    copy: Annotated[bool, Doc(\"Whether to copy the file to the run directory\")] = False,\n    move: Annotated[bool, Doc(\"Whether to move the file to the run directory\")] = False,\n    ignore_missing: Annotated[bool, Doc(\"Whether to ignore if the file does not exist\")] = False,\n    path_relative_to_project_root: Annotated[\n        bool,\n        Doc(\n            \"Whether `path` is relative to the project root. Will be ignored if `path` is absolute.\"\n            \"If True, it will be interpreted as relative to the project root. \"\n            \"If False, `path` will be interpreted as relative to the current working directory. \"\n            \"It is recommended to set this to True in the configuration file.\",\n        ),\n    ] = False,\n) -&gt; Callable[[CapsuleParams], FileContext]:\n    if copy and move:\n        warnings.warn(\"Both copy and move are True. Only move will be performed.\", UserWarning, stacklevel=2)\n        move = True\n        copy = False\n\n    def callback(params: CapsuleParams) -&gt; FileContext:\n        if path_relative_to_project_root and path is not None and not Path(path).is_absolute():\n            file_path = params.project_root / path\n        else:\n            file_path = Path(path)\n\n        return cls(\n            path=file_path,\n            compute_hash=compute_hash,\n            hash_algorithm=hash_algorithm,\n            copy_to=params.run_dir if copy else None,\n            move_to=params.run_dir if move else None,\n            ignore_missing=ignore_missing,\n        )\n\n    return callback\n</code></pre>"},{"location":"contexts/file/#capsula.FileContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _FileContextData\n</code></pre> Source code in <code>capsula/_context/_file.py</code> <pre><code>def encapsulate(self) -&gt; _FileContextData:\n    if not self._path.exists():\n        if self._ignore_missing:\n            logger.warning(f\"File {self._path} does not exist. Ignoring.\")\n            return _FileContextData(copied_to=(), moved_to=None, hash=None)\n        else:\n            msg = f\"File {self._path} does not exist.\"\n            raise FileNotFoundError(msg)\n    self._copy_to = tuple(self._normalize_copy_dst_path(p) for p in self._copy_to)\n\n    if self._compute_hash:\n        with self._path.open(\"rb\") as f:\n            digest = file_digest(f, self._hash_algorithm).hexdigest()\n        hash_data = {\n            \"algorithm\": self._hash_algorithm,\n            \"digest\": digest,\n        }\n    else:\n        hash_data = None\n\n    info: _FileContextData = {\n        \"copied_to\": self._copy_to,\n        \"moved_to\": self._move_to,\n        \"hash\": hash_data,\n    }\n\n    for path in self._copy_to:\n        copyfile(self._path, path)\n    if self._move_to is not None:\n        move(str(self._path), self._move_to)\n\n    return info\n</code></pre>"},{"location":"contexts/file/#capsula.FileContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_file.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"file\", str(self._path))\n</code></pre>"},{"location":"contexts/git/","title":"<code>GitRepositoryContext</code>","text":""},{"location":"contexts/git/#capsula.GitRepositoryContext","title":"capsula.GitRepositoryContext","text":"<pre><code>GitRepositoryContext(\n    name: str,\n    *,\n    path: Path | str,\n    diff_file: Path | str | None = None,\n    search_parent_directories: bool = False,\n    allow_dirty: bool = True\n)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture a Git repository.</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>path</code> <p> TYPE: <code>Path | str</code> </p> <code>diff_file</code> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>search_parent_directories</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>allow_dirty</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_context/_git.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    path: Path | str,\n    diff_file: Path | str | None = None,\n    search_parent_directories: bool = False,\n    allow_dirty: bool = True,\n) -&gt; None:\n    self._name = name\n    self._path = Path(path)\n    self._search_parent_directories = search_parent_directories\n    self._allow_dirty = allow_dirty\n    self._diff_file = None if diff_file is None else Path(diff_file)\n</code></pre>"},{"location":"contexts/git/#capsula.GitRepositoryContext.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    name: str | None = None,\n    *,\n    path: Path | str | None = None,\n    path_relative_to_project_root: bool = False,\n    allow_dirty: bool = True\n) -&gt; Callable[[CapsuleParams], GitRepositoryContext]\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the Git repository</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>Path to the Git repository</p> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>path_relative_to_project_root</code> <p>Whether <code>path</code> is relative to the project root. Will be ignored if <code>path</code> is None or absolute. If True, it will be interpreted as relative to the project root. If False, <code>path</code> will be interpreted as relative to the current working directory. It is recommended to set this to True in the configuration file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>allow_dirty</code> <p>Whether to allow the repository to be dirty</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_context/_git.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    name: Annotated[str | None, Doc(\"Name of the Git repository\")] = None,\n    *,\n    path: Annotated[Path | str | None, Doc(\"Path to the Git repository\")] = None,\n    path_relative_to_project_root: Annotated[\n        bool,\n        Doc(\n            \"Whether `path` is relative to the project root. Will be ignored if `path` is None or absolute. \"\n            \"If True, it will be interpreted as relative to the project root. \"\n            \"If False, `path` will be interpreted as relative to the current working directory. \"\n            \"It is recommended to set this to True in the configuration file.\",\n        ),\n    ] = False,\n    allow_dirty: Annotated[bool, Doc(\"Whether to allow the repository to be dirty\")] = True,\n) -&gt; Callable[[CapsuleParams], GitRepositoryContext]:\n    def callback(params: CapsuleParams) -&gt; GitRepositoryContext:\n        if path_relative_to_project_root and path is not None and not Path(path).is_absolute():\n            repository_path: Path | None = params.project_root / path\n        else:\n            repository_path = Path(path) if path is not None else None\n\n        if repository_path is not None:\n            repo = Repo(repository_path, search_parent_directories=False)\n        else:\n            if isinstance(params.exec_info, FuncInfo):\n                repo_search_start_path = Path(inspect.getfile(params.exec_info.func)).parent\n            elif isinstance(params.exec_info, CommandInfo) or params.exec_info is None:\n                repo_search_start_path = Path.cwd()\n            else:\n                msg = f\"exec_info must be an instance of FuncInfo or CommandInfo, not {type(params.exec_info)}.\"\n                raise TypeError(msg)\n            repo = Repo(repo_search_start_path, search_parent_directories=True)\n\n        repo_name = Path(repo.working_dir).name\n\n        return cls(\n            name=Path(repo.working_dir).name if name is None else name,\n            path=Path(repo.working_dir),\n            diff_file=params.run_dir / f\"{repo_name}.diff\",\n            search_parent_directories=False,\n            allow_dirty=allow_dirty,\n        )\n\n    return callback\n</code></pre>"},{"location":"contexts/git/#capsula.GitRepositoryContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _GitRepositoryContextData\n</code></pre> Source code in <code>capsula/_context/_git.py</code> <pre><code>def encapsulate(self) -&gt; _GitRepositoryContextData:\n    repo = Repo(self._path, search_parent_directories=self._search_parent_directories)\n    if not self._allow_dirty and repo.is_dirty():\n        raise GitRepositoryDirtyError(repo)\n\n    def get_optional_branch_name(repo: Repo) -&gt; str | None:\n        try:\n            return repo.active_branch.name\n        except TypeError:\n            return None\n\n    info: _GitRepositoryContextData = {\n        \"working_dir\": repo.working_dir,\n        \"sha\": repo.head.commit.hexsha,\n        \"remotes\": {remote.name: remote.url for remote in repo.remotes},\n        \"branch\": get_optional_branch_name(repo),\n        \"is_dirty\": repo.is_dirty(),\n        \"diff_file\": None,\n    }\n\n    diff_txt = repo.git.diff()\n    if diff_txt:\n        assert self._diff_file is not None, \"diff_file is None\"\n        with self._diff_file.open(\"w\") as f:\n            f.write(diff_txt)\n        logger.debug(f\"Wrote diff to {self._diff_file}\")\n        info[\"diff_file\"] = self._diff_file\n    return info\n</code></pre>"},{"location":"contexts/git/#capsula.GitRepositoryContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_git.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"git\", self._name)\n</code></pre>"},{"location":"contexts/platform/","title":"<code>PlatformContext</code>","text":""},{"location":"contexts/platform/#capsula.PlatformContext","title":"capsula.PlatformContext","text":"<p>               Bases: <code>ContextBase</code></p> <p>Context to capture platform information, including Python version.</p>"},{"location":"contexts/platform/#capsula.PlatformContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _PlatformContextData\n</code></pre> Source code in <code>capsula/_context/_platform.py</code> <pre><code>def encapsulate(self) -&gt; _PlatformContextData:\n    return {\n        \"machine\": pf.machine(),\n        \"node\": pf.node(),\n        \"platform\": pf.platform(),\n        \"release\": pf.release(),\n        \"version\": pf.version(),\n        \"system\": pf.system(),\n        \"processor\": pf.processor(),\n        \"python\": {\n            \"executable_architecture\": {\n                \"bits\": pf.architecture()[0],\n                \"linkage\": pf.architecture()[1],\n            },\n            \"build_no\": pf.python_build()[0],\n            \"build_date\": pf.python_build()[1],\n            \"compiler\": pf.python_compiler(),\n            \"branch\": pf.python_branch(),\n            \"implementation\": pf.python_implementation(),\n            \"version\": pf.python_version(),\n        },\n    }\n</code></pre>"},{"location":"contexts/platform/#capsula.PlatformContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; str\n</code></pre> Source code in <code>capsula/_context/_platform.py</code> <pre><code>def default_key(self) -&gt; str:\n    return \"platform\"\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>capsula</li> </ul>"},{"location":"reference/capsula/","title":"Index","text":""},{"location":"reference/capsula/#capsula","title":"capsula","text":""},{"location":"reference/capsula/#capsula.Capsule","title":"Capsule","text":"<pre><code>Capsule(\n    data: Mapping[_ContextKey, Any],\n    fails: Mapping[_ContextKey, ExceptionInfo],\n)\n</code></pre> PARAMETER DESCRIPTION <code>data</code> <p> TYPE: <code>Mapping[_ContextKey, Any]</code> </p> <code>fails</code> <p> TYPE: <code>Mapping[_ContextKey, ExceptionInfo]</code> </p> Source code in <code>capsula/_capsule.py</code> <pre><code>def __init__(\n    self,\n    data: Mapping[_ContextKey, Any],\n    fails: Mapping[_ContextKey, ExceptionInfo],\n) -&gt; None:\n    self.data = dict(data)\n    self.fails = dict(fails)\n</code></pre>"},{"location":"reference/capsula/#capsula.Capsule.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = dict(data)\n</code></pre>"},{"location":"reference/capsula/#capsula.Capsule.fails","title":"fails  <code>instance-attribute</code>","text":"<pre><code>fails = dict(fails)\n</code></pre>"},{"location":"reference/capsula/#capsula.CommandContext","title":"CommandContext","text":"<pre><code>CommandContext(\n    command: str,\n    *,\n    cwd: Path | None = None,\n    check: bool = True,\n    abort_on_error: bool = True\n)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture the output of a command run in a subprocess.</p> PARAMETER DESCRIPTION <code>command</code> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>check</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>abort_on_error</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_context/_command.py</code> <pre><code>def __init__(\n    self,\n    command: str,\n    *,\n    cwd: Path | None = None,\n    check: bool = True,\n    abort_on_error: bool = True,\n) -&gt; None:\n    self._command = command\n    self._cwd = cwd\n    self._check = check\n    self._abort_on_error = abort_on_error\n</code></pre>"},{"location":"reference/capsula/#capsula.CommandContext.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    command: str,\n    *,\n    cwd: Path | str | None = None,\n    check: bool = True,\n    abort_on_error: bool = True,\n    cwd_relative_to_project_root: bool = False\n) -&gt; Callable[[CapsuleParams], CommandContext]\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>Command to run</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Working directory for the command, passed to the <code>cwd</code> argument of <code>subprocess.run</code></p> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>check</code> <p>Whether to raise an exception if the command returns a non-zero exit code, passed to the <code>check</code> argument of `subprocess.run</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>abort_on_error</code> <p>Whether to abort the encapsulation if the command returns a non-zero exit code</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>cwd_relative_to_project_root</code> <p>Whether <code>cwd</code> argument is relative to the project root. Will be ignored if <code>cwd</code> is None or absolute. If True, it will be interpreted as relative to the project root. If False, <code>cwd</code> will be interpreted as relative to the current working directory. It is recommended to set this to True in the configuration file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_context/_command.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    command: Annotated[str, Doc(\"Command to run\")],\n    *,\n    cwd: Annotated[\n        Path | str | None,\n        Doc(\"Working directory for the command, passed to the `cwd` argument of `subprocess.run`\"),\n    ] = None,\n    check: Annotated[\n        bool,\n        Doc(\n            \"Whether to raise an exception if the command returns a non-zero exit code, passed to the `check` \"\n            \"argument of `subprocess.run\",\n        ),\n    ] = True,\n    abort_on_error: Annotated[\n        bool,\n        Doc(\"Whether to abort the encapsulation if the command returns a non-zero exit code\"),\n    ] = True,\n    cwd_relative_to_project_root: Annotated[\n        bool,\n        Doc(\n            \"Whether `cwd` argument is relative to the project root. Will be ignored if `cwd` is None or absolute. \"\n            \"If True, it will be interpreted as relative to the project root. \"\n            \"If False, `cwd` will be interpreted as relative to the current working directory. \"\n            \"It is recommended to set this to True in the configuration file.\",\n        ),\n    ] = False,\n) -&gt; Callable[[CapsuleParams], CommandContext]:\n    def callback(params: CapsuleParams) -&gt; CommandContext:\n        if cwd_relative_to_project_root and cwd is not None and not Path(cwd).is_absolute():\n            cwd_path: Path | None = params.project_root / cwd\n        elif cwd_relative_to_project_root and cwd is None:\n            cwd_path = params.project_root\n        else:\n            cwd_path = Path(cwd) if cwd is not None else None\n\n        return cls(\n            command,\n            cwd=cwd_path,\n            check=check,\n            abort_on_error=abort_on_error,\n        )\n\n    return callback\n</code></pre>"},{"location":"reference/capsula/#capsula.CommandContext.abort_on_error","title":"abort_on_error  <code>property</code>","text":"<pre><code>abort_on_error: bool\n</code></pre>"},{"location":"reference/capsula/#capsula.CommandContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _CommandContextData\n</code></pre> Source code in <code>capsula/_context/_command.py</code> <pre><code>def encapsulate(self) -&gt; _CommandContextData:\n    logger.debug(f\"Running command: {self._command}\")\n    output = subprocess.run(  # noqa: S602\n        self._command,\n        shell=True,\n        text=True,\n        capture_output=True,\n        cwd=self._cwd,\n        check=self._check,\n    )\n    logger.debug(f\"Ran command: {self._command}. Result: {output}\")\n    return {\n        \"command\": self._command,\n        \"cwd\": self._cwd,\n        \"returncode\": output.returncode,\n        \"stdout\": output.stdout,\n        \"stderr\": output.stderr,\n    }\n</code></pre>"},{"location":"reference/capsula/#capsula.CommandContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_command.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"command\", self._command)\n</code></pre>"},{"location":"reference/capsula/#capsula.ContextBase","title":"ContextBase","text":"<p>               Bases: <code>CapsuleItem</code></p>"},{"location":"reference/capsula/#capsula.ContextBase.abort_on_error","title":"abort_on_error  <code>property</code>","text":"<pre><code>abort_on_error: bool\n</code></pre>"},{"location":"reference/capsula/#capsula.ContextBase.get_subclass","title":"get_subclass  <code>classmethod</code>","text":"<pre><code>get_subclass(name: str) -&gt; type[ContextBase]\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> Source code in <code>capsula/_context/_base.py</code> <pre><code>@classmethod\ndef get_subclass(cls, name: str) -&gt; type[ContextBase]:\n    return cls._subclass_registry[name]\n</code></pre>"},{"location":"reference/capsula/#capsula.CpuContext","title":"CpuContext","text":"<p>               Bases: <code>ContextBase</code></p> <p>Context to capture CPU information.</p>"},{"location":"reference/capsula/#capsula.CpuContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; dict[str, Any]\n</code></pre> Source code in <code>capsula/_context/_cpu.py</code> <pre><code>def encapsulate(self) -&gt; dict[str, Any]:\n    return get_cpu_info()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"reference/capsula/#capsula.CpuContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; str\n</code></pre> Source code in <code>capsula/_context/_cpu.py</code> <pre><code>def default_key(self) -&gt; str:\n    return \"cpu\"\n</code></pre>"},{"location":"reference/capsula/#capsula.CwdContext","title":"CwdContext","text":"<p>               Bases: <code>ContextBase</code></p> <p>Context to capture the current working directory.</p>"},{"location":"reference/capsula/#capsula.CwdContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; Path\n</code></pre> Source code in <code>capsula/_context/_cwd.py</code> <pre><code>def encapsulate(self) -&gt; Path:\n    return Path.cwd()\n</code></pre>"},{"location":"reference/capsula/#capsula.CwdContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; str\n</code></pre> Source code in <code>capsula/_context/_cwd.py</code> <pre><code>def default_key(self) -&gt; str:\n    return \"cwd\"\n</code></pre>"},{"location":"reference/capsula/#capsula.EnvVarContext","title":"EnvVarContext","text":"<pre><code>EnvVarContext(name: str)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture an environment variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the environment variable</p> <p> TYPE: <code>str</code> </p> Source code in <code>capsula/_context/_envvar.py</code> <pre><code>def __init__(self, name: Annotated[str, Doc(\"Name of the environment variable\")]) -&gt; None:\n    self.name = name\n</code></pre>"},{"location":"reference/capsula/#capsula.EnvVarContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"reference/capsula/#capsula.EnvVarContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; str | None\n</code></pre> Source code in <code>capsula/_context/_envvar.py</code> <pre><code>def encapsulate(self) -&gt; str | None:\n    return os.getenv(self.name)\n</code></pre>"},{"location":"reference/capsula/#capsula.EnvVarContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_envvar.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"env\", self.name)\n</code></pre>"},{"location":"reference/capsula/#capsula.FileContext","title":"FileContext","text":"<pre><code>FileContext(\n    path: Path | str,\n    *,\n    compute_hash: bool = True,\n    hash_algorithm: str | None = None,\n    copy_to: (\n        Iterable[Path | str] | Path | str | None\n    ) = None,\n    move_to: Path | str | None = None,\n    ignore_missing: bool = False\n)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture a file.</p> PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>Path | str</code> </p> <code>compute_hash</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hash_algorithm</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>copy_to</code> <p> TYPE: <code>Iterable[Path | str] | Path | str | None</code> DEFAULT: <code>None</code> </p> <code>move_to</code> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>ignore_missing</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_context/_file.py</code> <pre><code>def __init__(\n    self,\n    path: Path | str,\n    *,\n    compute_hash: bool = True,\n    hash_algorithm: str | None = None,\n    copy_to: Iterable[Path | str] | Path | str | None = None,\n    move_to: Path | str | None = None,\n    ignore_missing: bool = False,\n) -&gt; None:\n    self._path = Path(path)\n    self._hash_algorithm = self._default_hash_algorithm if hash_algorithm is None else hash_algorithm\n    self._compute_hash = compute_hash\n    self._move_to = None if move_to is None else Path(move_to)\n    self._ignore_missing = ignore_missing\n\n    if copy_to is None:\n        self._copy_to: tuple[Path, ...] = ()\n    elif isinstance(copy_to, (str, Path)):\n        self._copy_to = (Path(copy_to),)\n    else:\n        self._copy_to = tuple(Path(p) for p in copy_to)\n</code></pre>"},{"location":"reference/capsula/#capsula.FileContext.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    path: Path | str,\n    *,\n    compute_hash: bool = True,\n    hash_algorithm: str | None = None,\n    copy: bool = False,\n    move: bool = False,\n    ignore_missing: bool = False,\n    path_relative_to_project_root: bool = False\n) -&gt; Callable[[CapsuleParams], FileContext]\n</code></pre> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file</p> <p> TYPE: <code>Path | str</code> </p> <code>compute_hash</code> <p>Whether to compute the hash of the file</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hash_algorithm</code> <p>Hash algorithm to use. This will be fed to <code>hashlib.file_digest</code> as the <code>digest</code> argument.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the file to the run directory</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>move</code> <p>Whether to move the file to the run directory</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ignore_missing</code> <p>Whether to ignore if the file does not exist</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>path_relative_to_project_root</code> <p>Whether <code>path</code> is relative to the project root. Will be ignored if <code>path</code> is absolute.If True, it will be interpreted as relative to the project root. If False, <code>path</code> will be interpreted as relative to the current working directory. It is recommended to set this to True in the configuration file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_context/_file.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    path: Annotated[Path | str, Doc(\"Path to the file\")],\n    *,\n    compute_hash: Annotated[bool, Doc(\"Whether to compute the hash of the file\")] = True,\n    hash_algorithm: Annotated[\n        str | None,\n        Doc(\"Hash algorithm to use. This will be fed to `hashlib.file_digest` as the `digest` argument.\"),\n    ] = None,\n    copy: Annotated[bool, Doc(\"Whether to copy the file to the run directory\")] = False,\n    move: Annotated[bool, Doc(\"Whether to move the file to the run directory\")] = False,\n    ignore_missing: Annotated[bool, Doc(\"Whether to ignore if the file does not exist\")] = False,\n    path_relative_to_project_root: Annotated[\n        bool,\n        Doc(\n            \"Whether `path` is relative to the project root. Will be ignored if `path` is absolute.\"\n            \"If True, it will be interpreted as relative to the project root. \"\n            \"If False, `path` will be interpreted as relative to the current working directory. \"\n            \"It is recommended to set this to True in the configuration file.\",\n        ),\n    ] = False,\n) -&gt; Callable[[CapsuleParams], FileContext]:\n    if copy and move:\n        warnings.warn(\"Both copy and move are True. Only move will be performed.\", UserWarning, stacklevel=2)\n        move = True\n        copy = False\n\n    def callback(params: CapsuleParams) -&gt; FileContext:\n        if path_relative_to_project_root and path is not None and not Path(path).is_absolute():\n            file_path = params.project_root / path\n        else:\n            file_path = Path(path)\n\n        return cls(\n            path=file_path,\n            compute_hash=compute_hash,\n            hash_algorithm=hash_algorithm,\n            copy_to=params.run_dir if copy else None,\n            move_to=params.run_dir if move else None,\n            ignore_missing=ignore_missing,\n        )\n\n    return callback\n</code></pre>"},{"location":"reference/capsula/#capsula.FileContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _FileContextData\n</code></pre> Source code in <code>capsula/_context/_file.py</code> <pre><code>def encapsulate(self) -&gt; _FileContextData:\n    if not self._path.exists():\n        if self._ignore_missing:\n            logger.warning(f\"File {self._path} does not exist. Ignoring.\")\n            return _FileContextData(copied_to=(), moved_to=None, hash=None)\n        else:\n            msg = f\"File {self._path} does not exist.\"\n            raise FileNotFoundError(msg)\n    self._copy_to = tuple(self._normalize_copy_dst_path(p) for p in self._copy_to)\n\n    if self._compute_hash:\n        with self._path.open(\"rb\") as f:\n            digest = file_digest(f, self._hash_algorithm).hexdigest()\n        hash_data = {\n            \"algorithm\": self._hash_algorithm,\n            \"digest\": digest,\n        }\n    else:\n        hash_data = None\n\n    info: _FileContextData = {\n        \"copied_to\": self._copy_to,\n        \"moved_to\": self._move_to,\n        \"hash\": hash_data,\n    }\n\n    for path in self._copy_to:\n        copyfile(self._path, path)\n    if self._move_to is not None:\n        move(str(self._path), self._move_to)\n\n    return info\n</code></pre>"},{"location":"reference/capsula/#capsula.FileContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_file.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"file\", str(self._path))\n</code></pre>"},{"location":"reference/capsula/#capsula.GitRepositoryContext","title":"GitRepositoryContext","text":"<pre><code>GitRepositoryContext(\n    name: str,\n    *,\n    path: Path | str,\n    diff_file: Path | str | None = None,\n    search_parent_directories: bool = False,\n    allow_dirty: bool = True\n)\n</code></pre> <p>               Bases: <code>ContextBase</code></p> <p>Context to capture a Git repository.</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>path</code> <p> TYPE: <code>Path | str</code> </p> <code>diff_file</code> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>search_parent_directories</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>allow_dirty</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_context/_git.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    path: Path | str,\n    diff_file: Path | str | None = None,\n    search_parent_directories: bool = False,\n    allow_dirty: bool = True,\n) -&gt; None:\n    self._name = name\n    self._path = Path(path)\n    self._search_parent_directories = search_parent_directories\n    self._allow_dirty = allow_dirty\n    self._diff_file = None if diff_file is None else Path(diff_file)\n</code></pre>"},{"location":"reference/capsula/#capsula.GitRepositoryContext.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    name: str | None = None,\n    *,\n    path: Path | str | None = None,\n    path_relative_to_project_root: bool = False,\n    allow_dirty: bool = True\n) -&gt; Callable[[CapsuleParams], GitRepositoryContext]\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>Name of the Git repository</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>path</code> <p>Path to the Git repository</p> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> <code>path_relative_to_project_root</code> <p>Whether <code>path</code> is relative to the project root. Will be ignored if <code>path</code> is None or absolute. If True, it will be interpreted as relative to the project root. If False, <code>path</code> will be interpreted as relative to the current working directory. It is recommended to set this to True in the configuration file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>allow_dirty</code> <p>Whether to allow the repository to be dirty</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_context/_git.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    name: Annotated[str | None, Doc(\"Name of the Git repository\")] = None,\n    *,\n    path: Annotated[Path | str | None, Doc(\"Path to the Git repository\")] = None,\n    path_relative_to_project_root: Annotated[\n        bool,\n        Doc(\n            \"Whether `path` is relative to the project root. Will be ignored if `path` is None or absolute. \"\n            \"If True, it will be interpreted as relative to the project root. \"\n            \"If False, `path` will be interpreted as relative to the current working directory. \"\n            \"It is recommended to set this to True in the configuration file.\",\n        ),\n    ] = False,\n    allow_dirty: Annotated[bool, Doc(\"Whether to allow the repository to be dirty\")] = True,\n) -&gt; Callable[[CapsuleParams], GitRepositoryContext]:\n    def callback(params: CapsuleParams) -&gt; GitRepositoryContext:\n        if path_relative_to_project_root and path is not None and not Path(path).is_absolute():\n            repository_path: Path | None = params.project_root / path\n        else:\n            repository_path = Path(path) if path is not None else None\n\n        if repository_path is not None:\n            repo = Repo(repository_path, search_parent_directories=False)\n        else:\n            if isinstance(params.exec_info, FuncInfo):\n                repo_search_start_path = Path(inspect.getfile(params.exec_info.func)).parent\n            elif isinstance(params.exec_info, CommandInfo) or params.exec_info is None:\n                repo_search_start_path = Path.cwd()\n            else:\n                msg = f\"exec_info must be an instance of FuncInfo or CommandInfo, not {type(params.exec_info)}.\"\n                raise TypeError(msg)\n            repo = Repo(repo_search_start_path, search_parent_directories=True)\n\n        repo_name = Path(repo.working_dir).name\n\n        return cls(\n            name=Path(repo.working_dir).name if name is None else name,\n            path=Path(repo.working_dir),\n            diff_file=params.run_dir / f\"{repo_name}.diff\",\n            search_parent_directories=False,\n            allow_dirty=allow_dirty,\n        )\n\n    return callback\n</code></pre>"},{"location":"reference/capsula/#capsula.GitRepositoryContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _GitRepositoryContextData\n</code></pre> Source code in <code>capsula/_context/_git.py</code> <pre><code>def encapsulate(self) -&gt; _GitRepositoryContextData:\n    repo = Repo(self._path, search_parent_directories=self._search_parent_directories)\n    if not self._allow_dirty and repo.is_dirty():\n        raise GitRepositoryDirtyError(repo)\n\n    def get_optional_branch_name(repo: Repo) -&gt; str | None:\n        try:\n            return repo.active_branch.name\n        except TypeError:\n            return None\n\n    info: _GitRepositoryContextData = {\n        \"working_dir\": repo.working_dir,\n        \"sha\": repo.head.commit.hexsha,\n        \"remotes\": {remote.name: remote.url for remote in repo.remotes},\n        \"branch\": get_optional_branch_name(repo),\n        \"is_dirty\": repo.is_dirty(),\n        \"diff_file\": None,\n    }\n\n    diff_txt = repo.git.diff()\n    if diff_txt:\n        assert self._diff_file is not None, \"diff_file is None\"\n        with self._diff_file.open(\"w\") as f:\n            f.write(diff_txt)\n        logger.debug(f\"Wrote diff to {self._diff_file}\")\n        info[\"diff_file\"] = self._diff_file\n    return info\n</code></pre>"},{"location":"reference/capsula/#capsula.GitRepositoryContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_context/_git.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"git\", self._name)\n</code></pre>"},{"location":"reference/capsula/#capsula.PlatformContext","title":"PlatformContext","text":"<p>               Bases: <code>ContextBase</code></p> <p>Context to capture platform information, including Python version.</p>"},{"location":"reference/capsula/#capsula.PlatformContext.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; _PlatformContextData\n</code></pre> Source code in <code>capsula/_context/_platform.py</code> <pre><code>def encapsulate(self) -&gt; _PlatformContextData:\n    return {\n        \"machine\": pf.machine(),\n        \"node\": pf.node(),\n        \"platform\": pf.platform(),\n        \"release\": pf.release(),\n        \"version\": pf.version(),\n        \"system\": pf.system(),\n        \"processor\": pf.processor(),\n        \"python\": {\n            \"executable_architecture\": {\n                \"bits\": pf.architecture()[0],\n                \"linkage\": pf.architecture()[1],\n            },\n            \"build_no\": pf.python_build()[0],\n            \"build_date\": pf.python_build()[1],\n            \"compiler\": pf.python_compiler(),\n            \"branch\": pf.python_branch(),\n            \"implementation\": pf.python_implementation(),\n            \"version\": pf.python_version(),\n        },\n    }\n</code></pre>"},{"location":"reference/capsula/#capsula.PlatformContext.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; str\n</code></pre> Source code in <code>capsula/_context/_platform.py</code> <pre><code>def default_key(self) -&gt; str:\n    return \"platform\"\n</code></pre>"},{"location":"reference/capsula/#capsula.context","title":"context","text":"<pre><code>context(\n    context: (\n        ContextBase | Callable[[CapsuleParams], ContextBase]\n    ),\n    mode: Literal[\"pre\", \"post\", \"all\"],\n) -&gt; Callable[\n    [Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]\n]\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ContextBase | Callable[[CapsuleParams], ContextBase]</code> </p> <code>mode</code> <p> TYPE: <code>Literal['pre', 'post', 'all']</code> </p> Source code in <code>capsula/_decorator.py</code> <pre><code>def context(\n    context: ContextBase | Callable[[CapsuleParams], ContextBase],\n    mode: Literal[\"pre\", \"post\", \"all\"],\n) -&gt; Callable[[Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]]:\n    def decorator(func_or_run: Callable[_P, _T] | Run[_P, _T]) -&gt; Run[_P, _T]:\n        run = func_or_run if isinstance(func_or_run, Run) else Run(func_or_run)\n        run.add_context(context, mode=mode, append_left=True)\n        return run\n\n    return decorator\n</code></pre>"},{"location":"reference/capsula/#capsula.pass_pre_run_capsule","title":"pass_pre_run_capsule","text":"<pre><code>pass_pre_run_capsule(\n    func: Callable[Concatenate[Capsule, _P], _T]\n) -&gt; Run[_P, _T]\n</code></pre> PARAMETER DESCRIPTION <code>func</code> <p> TYPE: <code>Callable[Concatenate[Capsule, _P], _T]</code> </p> Source code in <code>capsula/_decorator.py</code> <pre><code>def pass_pre_run_capsule(func: Callable[Concatenate[Capsule, _P], _T]) -&gt; Run[_P, _T]:\n    return Run(func, pass_pre_run_capsule=True)\n</code></pre>"},{"location":"reference/capsula/#capsula.reporter","title":"reporter","text":"<pre><code>reporter(\n    reporter: (\n        ReporterBase\n        | Callable[[CapsuleParams], ReporterBase]\n    ),\n    mode: Literal[\"pre\", \"in\", \"post\", \"all\"],\n) -&gt; Callable[\n    [Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]\n]\n</code></pre> PARAMETER DESCRIPTION <code>reporter</code> <p> TYPE: <code>ReporterBase | Callable[[CapsuleParams], ReporterBase]</code> </p> <code>mode</code> <p> TYPE: <code>Literal['pre', 'in', 'post', 'all']</code> </p> Source code in <code>capsula/_decorator.py</code> <pre><code>def reporter(\n    reporter: ReporterBase | Callable[[CapsuleParams], ReporterBase],\n    mode: Literal[\"pre\", \"in\", \"post\", \"all\"],\n) -&gt; Callable[[Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]]:\n    def decorator(func_or_run: Callable[_P, _T] | Run[_P, _T]) -&gt; Run[_P, _T]:\n        run = func_or_run if isinstance(func_or_run, Run) else Run(func_or_run)\n        run.add_reporter(reporter, mode=mode, append_left=True)\n        return run\n\n    return decorator\n</code></pre>"},{"location":"reference/capsula/#capsula.run","title":"run","text":"<pre><code>run(\n    run_dir: (\n        Path | Callable[[FuncInfo], Path] | None\n    ) = None,\n    *,\n    ignore_config: bool = False,\n    config_path: Path | str | None = None\n) -&gt; Callable[\n    [Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]\n]\n</code></pre> PARAMETER DESCRIPTION <code>run_dir</code> <p> TYPE: <code>Path | Callable[[FuncInfo], Path] | None</code> DEFAULT: <code>None</code> </p> <code>ignore_config</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>config_path</code> <p> TYPE: <code>Path | str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>capsula/_decorator.py</code> <pre><code>def run(\n    run_dir: Path | Callable[[FuncInfo], Path] | None = None,\n    *,\n    ignore_config: bool = False,\n    config_path: Path | str | None = None,\n) -&gt; Callable[[Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]]:\n    run_dir = generate_default_run_dir if run_dir is None else run_dir\n\n    def decorator(func_or_run: Callable[_P, _T] | Run[_P, _T]) -&gt; Run[_P, _T]:\n        run = func_or_run if isinstance(func_or_run, Run) else Run(func_or_run)\n        run.set_run_dir(run_dir)\n\n        if not ignore_config:\n            config = load_config(get_default_config_path() if config_path is None else Path(config_path))\n            for phase in (\"pre\", \"in\", \"post\"):\n                phase_key = f\"{phase}-run\"\n                if phase_key not in config:\n                    continue\n                for context in reversed(config[phase_key].get(\"contexts\", [])):  # type: ignore[literal-required]\n                    assert phase in {\"pre\", \"post\"}, f\"Invalid phase for context: {phase}\"\n                    run.add_context(context, mode=phase, append_left=True)  # type: ignore[arg-type]\n                for watcher in reversed(config[phase_key].get(\"watchers\", [])):  # type: ignore[literal-required]\n                    assert phase == \"in\", \"Watcher can only be added to the in-run phase.\"\n                    # No need to set append_left=True here, as watchers are added as the outermost context manager\n                    run.add_watcher(watcher, append_left=False)\n                for reporter in reversed(config[phase_key].get(\"reporters\", [])):  # type: ignore[literal-required]\n                    assert phase in {\"pre\", \"in\", \"post\"}, f\"Invalid phase for reporter: {phase}\"\n                    run.add_reporter(reporter, mode=phase, append_left=True)  # type: ignore[arg-type]\n\n        return run\n\n    return decorator\n</code></pre>"},{"location":"reference/capsula/#capsula.watcher","title":"watcher","text":"<pre><code>watcher(\n    watcher: (\n        WatcherBase | Callable[[CapsuleParams], WatcherBase]\n    )\n) -&gt; Callable[\n    [Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]\n]\n</code></pre> PARAMETER DESCRIPTION <code>watcher</code> <p> TYPE: <code>WatcherBase | Callable[[CapsuleParams], WatcherBase]</code> </p> Source code in <code>capsula/_decorator.py</code> <pre><code>def watcher(\n    watcher: WatcherBase | Callable[[CapsuleParams], WatcherBase],\n) -&gt; Callable[[Callable[_P, _T] | Run[_P, _T]], Run[_P, _T]]:\n    def decorator(func_or_run: Callable[_P, _T] | Run[_P, _T]) -&gt; Run[_P, _T]:\n        run = func_or_run if isinstance(func_or_run, Run) else Run(func_or_run)\n        # No need to set append_left=True here, as watchers are added as the outermost context manager\n        run.add_watcher(watcher, append_left=False)\n        return run\n\n    return decorator\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator","title":"Encapsulator","text":"<pre><code>Encapsulator()\n</code></pre> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.contexts: OrderedDict[_CapsuleItemKey, ContextBase] = OrderedDict()\n    self.watchers: OrderedDict[_CapsuleItemKey, WatcherBase] = OrderedDict()\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.get_current","title":"get_current  <code>classmethod</code>","text":"<pre><code>get_current() -&gt; Self | None\n</code></pre> Source code in <code>capsula/_encapsulator.py</code> <pre><code>@classmethod\ndef get_current(cls) -&gt; Self | None:\n    try:\n        return cls._get_context_stack().queue[-1]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.contexts","title":"contexts  <code>instance-attribute</code>","text":"<pre><code>contexts: OrderedDict[_CapsuleItemKey, ContextBase] = (\n    OrderedDict()\n)\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.watchers","title":"watchers  <code>instance-attribute</code>","text":"<pre><code>watchers: OrderedDict[_CapsuleItemKey, WatcherBase] = (\n    OrderedDict()\n)\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    self._get_context_stack().put(self)\n    return self\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>exc_type</code> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_value</code> <p> TYPE: <code>BaseException | None</code> </p> <code>traceback</code> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n    self._get_context_stack().get(block=False)\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.add_context","title":"add_context","text":"<pre><code>add_context(\n    context: ContextBase, key: _CapsuleItemKey | None = None\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ContextBase</code> </p> <code>key</code> <p> TYPE: <code>_CapsuleItemKey | None</code> DEFAULT: <code>None</code> </p> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def add_context(self, context: ContextBase, key: _CapsuleItemKey | None = None) -&gt; None:\n    if key is None:\n        key = context.default_key()\n    if key in self.contexts or key in self.watchers:\n        raise KeyConflictError(key)\n    self.contexts[key] = context\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.record","title":"record","text":"<pre><code>record(key: _CapsuleItemKey, record: Any) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p> TYPE: <code>_CapsuleItemKey</code> </p> <code>record</code> <p> TYPE: <code>Any</code> </p> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def record(self, key: _CapsuleItemKey, record: Any) -&gt; None:\n    self.add_context(ObjectContext(record), key)\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.add_watcher","title":"add_watcher","text":"<pre><code>add_watcher(\n    watcher: WatcherBase, key: _CapsuleItemKey | None = None\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>watcher</code> <p> TYPE: <code>WatcherBase</code> </p> <code>key</code> <p> TYPE: <code>_CapsuleItemKey | None</code> DEFAULT: <code>None</code> </p> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def add_watcher(self, watcher: WatcherBase, key: _CapsuleItemKey | None = None) -&gt; None:\n    if key is None:\n        key = watcher.default_key()\n    if key in self.contexts or key in self.watchers:\n        raise KeyConflictError(key)\n    self.watchers[key] = watcher\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; Capsule\n</code></pre> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def encapsulate(self) -&gt; Capsule:\n    data = {}\n    fails = {}\n    for key, capsule_item in chain(self.contexts.items(), self.watchers.items()):\n        try:\n            data[key] = capsule_item.encapsulate()\n        except Exception as e:  # noqa: PERF203\n            if capsule_item.abort_on_error:\n                raise\n            warnings.warn(f\"Error occurred during encapsulation of {key}: {e}. Skipping.\", stacklevel=3)\n            fails[key] = ExceptionInfo.from_exception(e)\n    return Capsule(data, fails)\n</code></pre>"},{"location":"reference/capsula/#capsula.Encapsulator.watch","title":"watch","text":"<pre><code>watch() -&gt; WatcherGroup[_CapsuleItemKey, WatcherBase]\n</code></pre> Source code in <code>capsula/_encapsulator.py</code> <pre><code>def watch(self) -&gt; WatcherGroup[_CapsuleItemKey, WatcherBase]:\n    return WatcherGroup(self.watchers)\n</code></pre>"},{"location":"reference/capsula/#capsula.CapsulaConfigurationError","title":"CapsulaConfigurationError","text":"<p>               Bases: <code>CapsulaError</code></p>"},{"location":"reference/capsula/#capsula.CapsulaError","title":"CapsulaError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/capsula/#capsula.JsonDumpReporter","title":"JsonDumpReporter","text":"<pre><code>JsonDumpReporter(\n    path: Path | str,\n    *,\n    default: Callable[[Any], Any] | None = None,\n    option: int | None = None,\n    mkdir: bool = True\n)\n</code></pre> <p>               Bases: <code>ReporterBase</code></p> <p>Reporter to dump the capsule to a JSON file.</p> PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>Path | str</code> </p> <code>default</code> <p> TYPE: <code>Callable[[Any], Any] | None</code> DEFAULT: <code>None</code> </p> <code>option</code> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>mkdir</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_reporter/_json.py</code> <pre><code>def __init__(\n    self,\n    path: Path | str,\n    *,\n    default: Callable[[Any], Any] | None = None,\n    option: int | None = None,\n    mkdir: bool = True,\n) -&gt; None:\n    self._path = Path(path)\n    if mkdir:\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n\n    if default is None:\n        self._default_for_encoder = default_preset\n    else:\n\n        def _default(obj: Any) -&gt; Any:\n            try:\n                return default_preset(obj)\n            except TypeError:\n                return default(obj)\n\n        self._default_for_encoder = _default\n\n    self._option = option\n</code></pre>"},{"location":"reference/capsula/#capsula.JsonDumpReporter.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    *, option: int | None = None\n) -&gt; Callable[[CapsuleParams], JsonDumpReporter]\n</code></pre> PARAMETER DESCRIPTION <code>option</code> <p>Option to pass to <code>orjson.dumps</code>. If not provided, <code>orjson.OPT_INDENT_2</code> will be used.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>capsula/_reporter/_json.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    *,\n    option: Annotated[\n        int | None,\n        Doc(\"Option to pass to `orjson.dumps`. If not provided, `orjson.OPT_INDENT_2` will be used.\"),\n    ] = None,\n) -&gt; Callable[[CapsuleParams], JsonDumpReporter]:\n    def callback(params: CapsuleParams) -&gt; JsonDumpReporter:\n        return cls(\n            params.run_dir / f\"{params.phase}-run-report.json\",\n            option=orjson.OPT_INDENT_2 if option is None else option,\n        )\n\n    return callback\n</code></pre>"},{"location":"reference/capsula/#capsula.JsonDumpReporter.report","title":"report","text":"<pre><code>report(capsule: Capsule) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>capsule</code> <p> TYPE: <code>Capsule</code> </p> Source code in <code>capsula/_reporter/_json.py</code> <pre><code>def report(self, capsule: Capsule) -&gt; None:\n    logger.debug(f\"Dumping capsule to {self._path}\")\n\n    def _str_to_tuple(s: str | tuple[str, ...]) -&gt; tuple[str, ...]:\n        if isinstance(s, str):\n            return (s,)\n        return s\n\n    nested_data = to_nested_dict({_str_to_tuple(k): v for k, v in capsule.data.items()})\n    if capsule.fails:\n        nested_data[\"__fails\"] = to_nested_dict({_str_to_tuple(k): v for k, v in capsule.fails.items()})\n\n    json_bytes = orjson.dumps(nested_data, default=self._default_for_encoder, option=self._option)\n    self._path.write_bytes(json_bytes)\n</code></pre>"},{"location":"reference/capsula/#capsula.ReporterBase","title":"ReporterBase","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/capsula/#capsula.ReporterBase.get_subclass","title":"get_subclass  <code>classmethod</code>","text":"<pre><code>get_subclass(name: str) -&gt; type[ReporterBase]\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> Source code in <code>capsula/_reporter/_base.py</code> <pre><code>@classmethod\ndef get_subclass(cls, name: str) -&gt; type[ReporterBase]:\n    return cls._subclass_registry[name]\n</code></pre>"},{"location":"reference/capsula/#capsula.ReporterBase.report","title":"report  <code>abstractmethod</code>","text":"<pre><code>report(capsule: Capsule) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>capsule</code> <p> TYPE: <code>Capsule</code> </p> Source code in <code>capsula/_reporter/_base.py</code> <pre><code>@abstractmethod\ndef report(self, capsule: Capsule) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/capsula/#capsula.ReporterBase.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    *args: Any, **kwargs: Any\n) -&gt; Callable[[CapsuleParams], Self]\n</code></pre> PARAMETER DESCRIPTION <code>*args</code> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>capsula/_reporter/_base.py</code> <pre><code>@classmethod\ndef builder(cls, *args: Any, **kwargs: Any) -&gt; Callable[[CapsuleParams], Self]:\n    def callback(params: CapsuleParams) -&gt; Self:  # type: ignore[type-var,misc] # noqa: ARG001\n        return cls(*args, **kwargs)\n\n    return callback\n</code></pre>"},{"location":"reference/capsula/#capsula.ReporterBase.default","title":"default  <code>classmethod</code>","text":"<pre><code>default(\n    *args: Any, **kwargs: Any\n) -&gt; Callable[[CapsuleParams], Self]\n</code></pre> Deprecated since v0.4.0. <p>Use <code>builder</code> method instead.</p> PARAMETER DESCRIPTION <code>*args</code> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[CapsuleParams], Self]</code> Source code in <code>capsula/_reporter/_base.py</code> <pre><code>@classmethod\n@deprecated(\"Use builder instead\")\ndef default(\n    cls,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Annotated[\n    Callable[[CapsuleParams], Self],\n    deprecated(\"\"\"Deprecated since v0.4.0.\n\n        Use `builder` method instead.\n        \"\"\"),\n]:\n    return cls.builder(*args, **kwargs)\n</code></pre>"},{"location":"reference/capsula/#capsula.current_run_name","title":"current_run_name","text":"<pre><code>current_run_name() -&gt; str\n</code></pre> Source code in <code>capsula/_root.py</code> <pre><code>def current_run_name() -&gt; str:\n    run: Run[Any, Any] | None = Run.get_current()\n    if run is None:\n        msg = \"No active run found.\"\n        raise RuntimeError(msg)\n    return run.run_dir.name\n</code></pre>"},{"location":"reference/capsula/#capsula.record","title":"record","text":"<pre><code>record(key: _CapsuleItemKey, value: Any) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p> TYPE: <code>_CapsuleItemKey</code> </p> <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>capsula/_root.py</code> <pre><code>def record(key: _CapsuleItemKey, value: Any) -&gt; None:\n    enc = Encapsulator.get_current()\n    if enc is None:\n        msg = \"No active encapsulator found.\"\n        raise RuntimeError(msg)\n    enc.record(key, value)\n</code></pre>"},{"location":"reference/capsula/#capsula.Run","title":"Run","text":"<pre><code>Run(\n    func: (\n        Callable[_P, _T]\n        | Callable[Concatenate[Capsule, _P], _T]\n    ),\n    *,\n    pass_pre_run_capsule: bool = False\n)\n</code></pre> <p>               Bases: <code>Generic[_P, _T]</code></p> PARAMETER DESCRIPTION <code>func</code> <p> TYPE: <code>Callable[_P, _T] | Callable[Concatenate[Capsule, _P], _T]</code> </p> <code>pass_pre_run_capsule</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[_P, _T] | Callable[Concatenate[Capsule, _P], _T],\n    *,\n    pass_pre_run_capsule: bool = False,\n) -&gt; None:\n    self._pre_run_context_generators: deque[Callable[[CapsuleParams], ContextBase]] = deque()\n    self._in_run_watcher_generators: deque[Callable[[CapsuleParams], WatcherBase]] = deque()\n    self._post_run_context_generators: deque[Callable[[CapsuleParams], ContextBase]] = deque()\n\n    self._pre_run_reporter_generators: deque[Callable[[CapsuleParams], ReporterBase]] = deque()\n    self._in_run_reporter_generators: deque[Callable[[CapsuleParams], ReporterBase]] = deque()\n    self._post_run_reporter_generators: deque[Callable[[CapsuleParams], ReporterBase]] = deque()\n\n    self._pass_pre_run_capsule: bool = pass_pre_run_capsule\n    self._func: Callable[_P, _T] | Callable[Concatenate[Capsule, _P], _T] = func\n\n    self._run_dir_generator: Callable[[FuncInfo], Path] | None = None\n    self._run_dir: Path | None = None\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.get_current","title":"get_current  <code>classmethod</code>","text":"<pre><code>get_current() -&gt; Self | None\n</code></pre> Source code in <code>capsula/_run.py</code> <pre><code>@classmethod\ndef get_current(cls) -&gt; Self | None:\n    try:\n        return cls._get_run_stack().queue[-1]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.run_dir","title":"run_dir  <code>property</code>","text":"<pre><code>run_dir: Path\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.add_context","title":"add_context","text":"<pre><code>add_context(\n    context: (\n        ContextBase | Callable[[CapsuleParams], ContextBase]\n    ),\n    *,\n    mode: Literal[\"pre\", \"post\", \"all\"],\n    append_left: bool = False\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>context</code> <p> TYPE: <code>ContextBase | Callable[[CapsuleParams], ContextBase]</code> </p> <code>mode</code> <p> TYPE: <code>Literal['pre', 'post', 'all']</code> </p> <code>append_left</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def add_context(\n    self,\n    context: ContextBase | Callable[[CapsuleParams], ContextBase],\n    *,\n    mode: Literal[\"pre\", \"post\", \"all\"],\n    append_left: bool = False,\n) -&gt; None:\n    def context_generator(params: CapsuleParams) -&gt; ContextBase:\n        if isinstance(context, ContextBase):\n            return context\n        else:\n            return context(params)\n\n    if mode == \"pre\":\n        if append_left:\n            self._pre_run_context_generators.appendleft(context_generator)\n        else:\n            self._pre_run_context_generators.append(context_generator)\n    elif mode == \"post\":\n        if append_left:\n            self._post_run_context_generators.appendleft(context_generator)\n        else:\n            self._post_run_context_generators.append(context_generator)\n    elif mode == \"all\":\n        if append_left:\n            self._pre_run_context_generators.appendleft(context_generator)\n            self._post_run_context_generators.appendleft(context_generator)\n        else:\n            self._pre_run_context_generators.append(context_generator)\n            self._post_run_context_generators.append(context_generator)\n    else:\n        msg = f\"mode must be one of 'pre', 'post', or 'all', not {mode}.\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.add_watcher","title":"add_watcher","text":"<pre><code>add_watcher(\n    watcher: (\n        WatcherBase | Callable[[CapsuleParams], WatcherBase]\n    ),\n    *,\n    append_left: bool = False\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>watcher</code> <p> TYPE: <code>WatcherBase | Callable[[CapsuleParams], WatcherBase]</code> </p> <code>append_left</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def add_watcher(\n    self,\n    watcher: WatcherBase | Callable[[CapsuleParams], WatcherBase],\n    *,\n    append_left: bool = False,\n) -&gt; None:\n    def watcher_generator(params: CapsuleParams) -&gt; WatcherBase:\n        if isinstance(watcher, WatcherBase):\n            return watcher\n        else:\n            return watcher(params)\n\n    if append_left:\n        self._in_run_watcher_generators.appendleft(watcher_generator)\n    else:\n        self._in_run_watcher_generators.append(watcher_generator)\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.add_reporter","title":"add_reporter","text":"<pre><code>add_reporter(\n    reporter: (\n        ReporterBase\n        | Callable[[CapsuleParams], ReporterBase]\n    ),\n    *,\n    mode: Literal[\"pre\", \"in\", \"post\", \"all\"],\n    append_left: bool = False\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>reporter</code> <p> TYPE: <code>ReporterBase | Callable[[CapsuleParams], ReporterBase]</code> </p> <code>mode</code> <p> TYPE: <code>Literal['pre', 'in', 'post', 'all']</code> </p> <code>append_left</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def add_reporter(  # noqa: C901, PLR0912\n    self,\n    reporter: ReporterBase | Callable[[CapsuleParams], ReporterBase],\n    *,\n    mode: Literal[\"pre\", \"in\", \"post\", \"all\"],\n    append_left: bool = False,\n) -&gt; None:\n    def reporter_generator(params: CapsuleParams) -&gt; ReporterBase:\n        if isinstance(reporter, ReporterBase):\n            return reporter\n        else:\n            return reporter(params)\n\n    if mode == \"pre\":\n        if append_left:\n            self._pre_run_reporter_generators.appendleft(reporter_generator)\n        else:\n            self._pre_run_reporter_generators.append(reporter_generator)\n    elif mode == \"in\":\n        if append_left:\n            self._in_run_reporter_generators.appendleft(reporter_generator)\n        else:\n            self._in_run_reporter_generators.append(reporter_generator)\n    elif mode == \"post\":\n        if append_left:\n            self._post_run_reporter_generators.appendleft(reporter_generator)\n        else:\n            self._post_run_reporter_generators.append(reporter_generator)\n    elif mode == \"all\":\n        if append_left:\n            self._pre_run_reporter_generators.appendleft(reporter_generator)\n            self._in_run_reporter_generators.appendleft(reporter_generator)\n            self._post_run_reporter_generators.appendleft(reporter_generator)\n        else:\n            self._pre_run_reporter_generators.append(reporter_generator)\n            self._in_run_reporter_generators.append(reporter_generator)\n            self._post_run_reporter_generators.append(reporter_generator)\n    else:\n        msg = f\"mode must be one of 'pre', 'in', 'post', or 'all', not {mode}.\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.set_run_dir","title":"set_run_dir","text":"<pre><code>set_run_dir(\n    run_dir: Path | Callable[[FuncInfo], Path]\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>run_dir</code> <p> TYPE: <code>Path | Callable[[FuncInfo], Path]</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def set_run_dir(self, run_dir: Path | Callable[[FuncInfo], Path]) -&gt; None:\n    def run_dir_generator(params: FuncInfo) -&gt; Path:\n        if isinstance(run_dir, Path):\n            return run_dir\n        else:\n            return run_dir(params)\n\n    self._run_dir_generator = run_dir_generator\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>capsula/_run.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    self._get_run_stack().put(self)\n    return self\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>exc_type</code> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_value</code> <p> TYPE: <code>BaseException | None</code> </p> <code>traceback</code> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n    self._get_run_stack().get(block=False)\n</code></pre>"},{"location":"reference/capsula/#capsula.Run.__call__","title":"__call__","text":"<pre><code>__call__(*args: args, **kwargs: kwargs) -&gt; _T\n</code></pre> PARAMETER DESCRIPTION <code>*args</code> <p> TYPE: <code>args</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p> TYPE: <code>kwargs</code> DEFAULT: <code>{}</code> </p> Source code in <code>capsula/_run.py</code> <pre><code>def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -&gt; _T:  # noqa: C901\n    func_info = FuncInfo(func=self._func, args=args, kwargs=kwargs)\n    if self._run_dir_generator is None:\n        msg = \"run_dir_generator must be set before calling the function.\"\n        raise ValueError(msg)\n    self._run_dir = self._run_dir_generator(func_info)\n    self._run_dir.mkdir(parents=True, exist_ok=True)\n    params = CapsuleParams(\n        exec_info=func_info,\n        run_dir=self._run_dir,\n        phase=\"pre\",\n        project_root=get_project_root(func_info),\n    )\n\n    pre_run_enc = Encapsulator()\n    for context_generator in self._pre_run_context_generators:\n        context = context_generator(params)\n        pre_run_enc.add_context(context)\n    pre_run_capsule = pre_run_enc.encapsulate()\n    for reporter_generator in self._pre_run_reporter_generators:\n        reporter = reporter_generator(params)\n        reporter.report(pre_run_capsule)\n\n    params.phase = \"in\"\n    in_run_enc = Encapsulator()\n    for watcher_generator in self._in_run_watcher_generators:\n        watcher = watcher_generator(params)\n        in_run_enc.add_watcher(watcher)\n\n    in_run_enc.add_context(FunctionCallContext(self._func, args, kwargs))\n\n    try:\n        with self, in_run_enc, in_run_enc.watch():\n            if self._pass_pre_run_capsule:\n                result = self._func(pre_run_capsule, *args, **kwargs)  # type: ignore[arg-type]\n            else:\n                result = self._func(*args, **kwargs)\n    finally:\n        in_run_capsule = in_run_enc.encapsulate()\n        for reporter_generator in self._in_run_reporter_generators:\n            reporter = reporter_generator(params)\n            try:\n                reporter.report(in_run_capsule)\n            except Exception:\n                logger.exception(f\"Failed to report in-run capsule with reporter {reporter}.\")\n\n        params.phase = \"post\"\n        post_run_enc = Encapsulator()\n        for context_generator in self._post_run_context_generators:\n            context = context_generator(params)\n            post_run_enc.add_context(context)\n        post_run_capsule = post_run_enc.encapsulate()\n        for reporter_generator in self._post_run_reporter_generators:\n            reporter = reporter_generator(params)\n            try:\n                reporter.report(post_run_capsule)\n            except Exception:\n                logger.exception(f\"Failed to report post-run capsule with reporter {reporter}.\")\n\n    return result\n</code></pre>"},{"location":"reference/capsula/#capsula.search_for_project_root","title":"search_for_project_root","text":"<pre><code>search_for_project_root(start: Path | str) -&gt; Path\n</code></pre> <p>Search for the project root directory by looking for pyproject.toml.</p> PARAMETER DESCRIPTION <code>start</code> <p> TYPE: <code>Path | str</code> </p> PARAMETER DESCRIPTION <code>start</code> <p>The start directory to search.</p> <p> TYPE: <code>Path | str</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>The project root directory.</p> Source code in <code>capsula/_utils.py</code> <pre><code>def search_for_project_root(start: Path | str) -&gt; Path:\n    \"\"\"Search for the project root directory by looking for pyproject.toml.\n\n    Args:\n        start: The start directory to search.\n\n    Returns:\n        The project root directory.\n\n    \"\"\"\n    start = Path(start)\n    if (start / \"pyproject.toml\").exists():\n        return start\n    if start == start.parent:\n        msg = \"Project root not found.\"\n        raise FileNotFoundError(msg)\n    return search_for_project_root(start.resolve().parent)\n</code></pre>"},{"location":"reference/capsula/#capsula.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = version('capsula')\n</code></pre>"},{"location":"reference/capsula/#capsula.TimeWatcher","title":"TimeWatcher","text":"<pre><code>TimeWatcher(name: str = 'execution_time')\n</code></pre> <p>               Bases: <code>WatcherBase</code></p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the time watcher. Used as a key in the output.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'execution_time'</code> </p> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>def __init__(\n    self,\n    name: Annotated[str, Doc(\"Name of the time watcher. Used as a key in the output.\")] = \"execution_time\",\n) -&gt; None:\n    self._name = name\n    self._duration: timedelta | None = None\n</code></pre>"},{"location":"reference/capsula/#capsula.TimeWatcher.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; timedelta | None\n</code></pre> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>def encapsulate(self) -&gt; timedelta | None:\n    return self._duration\n</code></pre>"},{"location":"reference/capsula/#capsula.TimeWatcher.watch","title":"watch","text":"<pre><code>watch() -&gt; Iterator[None]\n</code></pre> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>@contextmanager\ndef watch(self) -&gt; Iterator[None]:\n    start = time.perf_counter()\n    try:\n        yield\n    finally:\n        end = time.perf_counter()\n        self._duration = timedelta(seconds=end - start)\n        logger.debug(f\"TimeWatcher: {self._name} took {self._duration}.\")\n</code></pre>"},{"location":"reference/capsula/#capsula.TimeWatcher.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"time\", self._name)\n</code></pre>"},{"location":"reference/capsula/#capsula.UncaughtExceptionWatcher","title":"UncaughtExceptionWatcher","text":"<pre><code>UncaughtExceptionWatcher(\n    name: str = \"exception\",\n    *,\n    base: type[BaseException] = Exception\n)\n</code></pre> <p>               Bases: <code>WatcherBase</code></p> <p>Watcher to capture an uncaught exception.</p> <p>This watcher captures an uncaught exception and stores it in the context. Note that it does not consume the exception, so it will still be raised.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the exception. Used as a key in the output.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'exception'</code> </p> <code>base</code> <p>Base exception class to catch.</p> <p> TYPE: <code>type[BaseException]</code> DEFAULT: <code>Exception</code> </p> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>def __init__(\n    self,\n    name: Annotated[str, Doc(\"Name of the exception. Used as a key in the output.\")] = \"exception\",\n    *,\n    base: Annotated[type[BaseException], Doc(\"Base exception class to catch.\")] = Exception,\n) -&gt; None:\n    self._name = name\n    self._base = base\n    self._exception: BaseException | None = None\n</code></pre>"},{"location":"reference/capsula/#capsula.UncaughtExceptionWatcher.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; ExceptionInfo\n</code></pre> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>def encapsulate(self) -&gt; ExceptionInfo:\n    return ExceptionInfo.from_exception(self._exception)\n</code></pre>"},{"location":"reference/capsula/#capsula.UncaughtExceptionWatcher.watch","title":"watch","text":"<pre><code>watch() -&gt; Iterator[None]\n</code></pre> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>@contextmanager\ndef watch(self) -&gt; Iterator[None]:\n    self._exception = None\n    try:\n        yield\n    except self._base as e:\n        logger.debug(f\"UncaughtExceptionWatcher: {self._name} observed exception: {e}\")\n        self._exception = e\n        raise\n</code></pre>"},{"location":"reference/capsula/#capsula.UncaughtExceptionWatcher.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"exception\", self._name)\n</code></pre>"},{"location":"reference/capsula/#capsula.WatcherBase","title":"WatcherBase","text":"<p>               Bases: <code>CapsuleItem</code>, <code>ABC</code></p>"},{"location":"reference/capsula/#capsula.WatcherBase.abort_on_error","title":"abort_on_error  <code>property</code>","text":"<pre><code>abort_on_error: bool\n</code></pre>"},{"location":"reference/capsula/#capsula.WatcherBase.get_subclass","title":"get_subclass  <code>classmethod</code>","text":"<pre><code>get_subclass(name: str) -&gt; type[WatcherBase]\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> Source code in <code>capsula/_watcher/_base.py</code> <pre><code>@classmethod\ndef get_subclass(cls, name: str) -&gt; type[WatcherBase]:\n    return cls._subclass_registry[name]\n</code></pre>"},{"location":"reference/capsula/#capsula.WatcherBase.watch","title":"watch  <code>abstractmethod</code>","text":"<pre><code>watch() -&gt; AbstractContextManager[None]\n</code></pre> Source code in <code>capsula/_watcher/_base.py</code> <pre><code>@abstractmethod\ndef watch(self) -&gt; AbstractContextManager[None]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reporters/","title":"Built-in reporters","text":"<p>Capsula provides several built-in reporters that report the captured contexts.</p> <ul> <li><code>JsonDumpReporter</code> - Reports the capsule in JSON format.</li> </ul>"},{"location":"reporters/json_dump/","title":"<code>JsonDumpReporter</code>","text":""},{"location":"reporters/json_dump/#capsula.JsonDumpReporter","title":"capsula.JsonDumpReporter","text":"<pre><code>JsonDumpReporter(\n    path: Path | str,\n    *,\n    default: Callable[[Any], Any] | None = None,\n    option: int | None = None,\n    mkdir: bool = True\n)\n</code></pre> <p>               Bases: <code>ReporterBase</code></p> <p>Reporter to dump the capsule to a JSON file.</p> PARAMETER DESCRIPTION <code>path</code> <p> TYPE: <code>Path | str</code> </p> <code>default</code> <p> TYPE: <code>Callable[[Any], Any] | None</code> DEFAULT: <code>None</code> </p> <code>option</code> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>mkdir</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>capsula/_reporter/_json.py</code> <pre><code>def __init__(\n    self,\n    path: Path | str,\n    *,\n    default: Callable[[Any], Any] | None = None,\n    option: int | None = None,\n    mkdir: bool = True,\n) -&gt; None:\n    self._path = Path(path)\n    if mkdir:\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n\n    if default is None:\n        self._default_for_encoder = default_preset\n    else:\n\n        def _default(obj: Any) -&gt; Any:\n            try:\n                return default_preset(obj)\n            except TypeError:\n                return default(obj)\n\n        self._default_for_encoder = _default\n\n    self._option = option\n</code></pre>"},{"location":"reporters/json_dump/#capsula.JsonDumpReporter.builder","title":"builder  <code>classmethod</code>","text":"<pre><code>builder(\n    *, option: int | None = None\n) -&gt; Callable[[CapsuleParams], JsonDumpReporter]\n</code></pre> PARAMETER DESCRIPTION <code>option</code> <p>Option to pass to <code>orjson.dumps</code>. If not provided, <code>orjson.OPT_INDENT_2</code> will be used.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>capsula/_reporter/_json.py</code> <pre><code>@classmethod\ndef builder(\n    cls,\n    *,\n    option: Annotated[\n        int | None,\n        Doc(\"Option to pass to `orjson.dumps`. If not provided, `orjson.OPT_INDENT_2` will be used.\"),\n    ] = None,\n) -&gt; Callable[[CapsuleParams], JsonDumpReporter]:\n    def callback(params: CapsuleParams) -&gt; JsonDumpReporter:\n        return cls(\n            params.run_dir / f\"{params.phase}-run-report.json\",\n            option=orjson.OPT_INDENT_2 if option is None else option,\n        )\n\n    return callback\n</code></pre>"},{"location":"reporters/json_dump/#capsula.JsonDumpReporter.report","title":"report","text":"<pre><code>report(capsule: Capsule) -&gt; None\n</code></pre> PARAMETER DESCRIPTION <code>capsule</code> <p> TYPE: <code>Capsule</code> </p> Source code in <code>capsula/_reporter/_json.py</code> <pre><code>def report(self, capsule: Capsule) -&gt; None:\n    logger.debug(f\"Dumping capsule to {self._path}\")\n\n    def _str_to_tuple(s: str | tuple[str, ...]) -&gt; tuple[str, ...]:\n        if isinstance(s, str):\n            return (s,)\n        return s\n\n    nested_data = to_nested_dict({_str_to_tuple(k): v for k, v in capsule.data.items()})\n    if capsule.fails:\n        nested_data[\"__fails\"] = to_nested_dict({_str_to_tuple(k): v for k, v in capsule.fails.items()})\n\n    json_bytes = orjson.dumps(nested_data, default=self._default_for_encoder, option=self._option)\n    self._path.write_bytes(json_bytes)\n</code></pre>"},{"location":"watchers/","title":"Built-in watchers","text":"<p>Capsula provides several built-in watchers that you can use to monitor the execution of your command/function. The following is a list of built-in watchers:</p> <ul> <li><code>TimeWatcher</code> - Monitors the execution time.</li> <li><code>UncaughtExceptionWatcher</code> - Monitors uncaught exceptions.</li> </ul>"},{"location":"watchers/time/","title":"<code>TimeWatcher</code>","text":""},{"location":"watchers/time/#capsula.TimeWatcher","title":"capsula.TimeWatcher","text":"<pre><code>TimeWatcher(name: str = 'execution_time')\n</code></pre> <p>               Bases: <code>WatcherBase</code></p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the time watcher. Used as a key in the output.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'execution_time'</code> </p> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>def __init__(\n    self,\n    name: Annotated[str, Doc(\"Name of the time watcher. Used as a key in the output.\")] = \"execution_time\",\n) -&gt; None:\n    self._name = name\n    self._duration: timedelta | None = None\n</code></pre>"},{"location":"watchers/time/#capsula.TimeWatcher.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; timedelta | None\n</code></pre> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>def encapsulate(self) -&gt; timedelta | None:\n    return self._duration\n</code></pre>"},{"location":"watchers/time/#capsula.TimeWatcher.watch","title":"watch","text":"<pre><code>watch() -&gt; Iterator[None]\n</code></pre> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>@contextmanager\ndef watch(self) -&gt; Iterator[None]:\n    start = time.perf_counter()\n    try:\n        yield\n    finally:\n        end = time.perf_counter()\n        self._duration = timedelta(seconds=end - start)\n        logger.debug(f\"TimeWatcher: {self._name} took {self._duration}.\")\n</code></pre>"},{"location":"watchers/time/#capsula.TimeWatcher.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_watcher/_time.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"time\", self._name)\n</code></pre>"},{"location":"watchers/uncaught_exception/","title":"<code>UncaughtExceptionWatcher</code>","text":""},{"location":"watchers/uncaught_exception/#capsula.UncaughtExceptionWatcher","title":"capsula.UncaughtExceptionWatcher","text":"<pre><code>UncaughtExceptionWatcher(\n    name: str = \"exception\",\n    *,\n    base: type[BaseException] = Exception\n)\n</code></pre> <p>               Bases: <code>WatcherBase</code></p> <p>Watcher to capture an uncaught exception.</p> <p>This watcher captures an uncaught exception and stores it in the context. Note that it does not consume the exception, so it will still be raised.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the exception. Used as a key in the output.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'exception'</code> </p> <code>base</code> <p>Base exception class to catch.</p> <p> TYPE: <code>type[BaseException]</code> DEFAULT: <code>Exception</code> </p> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>def __init__(\n    self,\n    name: Annotated[str, Doc(\"Name of the exception. Used as a key in the output.\")] = \"exception\",\n    *,\n    base: Annotated[type[BaseException], Doc(\"Base exception class to catch.\")] = Exception,\n) -&gt; None:\n    self._name = name\n    self._base = base\n    self._exception: BaseException | None = None\n</code></pre>"},{"location":"watchers/uncaught_exception/#capsula.UncaughtExceptionWatcher.encapsulate","title":"encapsulate","text":"<pre><code>encapsulate() -&gt; ExceptionInfo\n</code></pre> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>def encapsulate(self) -&gt; ExceptionInfo:\n    return ExceptionInfo.from_exception(self._exception)\n</code></pre>"},{"location":"watchers/uncaught_exception/#capsula.UncaughtExceptionWatcher.watch","title":"watch","text":"<pre><code>watch() -&gt; Iterator[None]\n</code></pre> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>@contextmanager\ndef watch(self) -&gt; Iterator[None]:\n    self._exception = None\n    try:\n        yield\n    except self._base as e:\n        logger.debug(f\"UncaughtExceptionWatcher: {self._name} observed exception: {e}\")\n        self._exception = e\n        raise\n</code></pre>"},{"location":"watchers/uncaught_exception/#capsula.UncaughtExceptionWatcher.default_key","title":"default_key","text":"<pre><code>default_key() -&gt; tuple[str, str]\n</code></pre> Source code in <code>capsula/_watcher/_exception.py</code> <pre><code>def default_key(self) -&gt; tuple[str, str]:\n    return (\"exception\", self._name)\n</code></pre>"}]}